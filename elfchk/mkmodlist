#!/usr/bin/perl
use strict;
use DBI;
use Env qw(LSBUSER LSBDBPASSWD LSBDB LSBDBHOST);
use Getopt::Long;

sub usage()
{
print STDERR "Usage: mkmodlist -v <lsbversion(s)>\n";
print STDERR "    LSB versions should be comma-separated.\n";
die;
}

my $lsbversion;
GetOptions("v=s" => \$lsbversion);
if( !$lsbversion ) { usage(); }

my $lsbversion_min = "";
my $lsbversion_max = "";
my @lsbversions = sort split(/,/, $lsbversion);
foreach (@lsbversions) {
	$lsbversion_min = $_ if (($lsbversion_min eq "") or ($lsbversion_min > $_));
	$lsbversion_max = $_ if (($lsbversion_max eq "") or ($lsbversion_max < $_));
}

my $dbh = DBI->connect('DBI:mysql:database='.$LSBDB.';host='.$LSBDBHOST, $LSBUSER, $LSBDBPASSWD)
    or die "Couldn't connect to database: ".DBI->errstr;

my $select = "SELECT SMname,MSMappearedin,SMmandatorysince FROM SubModule LEFT JOIN ModSMod ON SMid=MSMsmid "
				."WHERE MSMappearedin BETWEEN '1.0' AND '$lsbversion_max' "
				."AND MSMwithdrawnin IS NULL ORDER BY SMname";

my $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;

my $flag = 1;
my %defines;
open(my $fd, ">modules.h");

print $fd q(/* GENERATED FILE, DO NOT MODIFY */
#ifndef MODULE_HEADER
#define MODULE_HEADER 1
#include <stdlib.h>

struct lsb_module {
	char *name;
	unsigned int flag;
};

extern struct lsb_module* LSB_Modules[];

);
my $count = 0;
my %desktop_defines;
my @versions_list;
for(1..$sth->rows) {
	my $row = $sth->fetchrow_hashref or die "Fetchrow failed on $select query: ".DBI->errstr;
	$row->{'SMname'}=~s/-/_/g;
	my $name;
	if(lc(substr($row->{'SMname'}, 0, 4)) == "lsb_") {
		$name = "LSB_".ucfirst(substr($row->{'SMname'},4));
	} else {
		$name = $row->{'SMname'};
	}
	printf $fd "#define $name\t0x%x\n", $flag;
	foreach my $ver (@lsbversions) {
		if ($ver >= $row->{'MSMappearedin'}) {
			$defines{$ver}->{$row->{'SMname'}} = $name;
		}
		if( ($row->{'SMmandatorysince'} ne "") and ($row->{'SMmandatorysince'} le $ver) ) {
			if (!defined($desktop_defines{$ver})) {
				my @temp = ();
				$desktop_defines{$ver} = \@temp;
			}
			push (@{$desktop_defines{$ver}}, $name);
		}
	}
	$flag <<= 1;
	$count++;
}
$count = (2 ** ($count + 8 - ($count % 8))) - 1;
printf $fd "#define LSB_Core_Modules 	(LSB_Core | LSB_Cpp)\n";
foreach my $ver (@lsbversions) {
	my $v = $ver;
	$v =~ s/\.//g;
	printf $fd "#define LSB_Desktop_Modules_LSB$v (%s)\n", join(" | ", @{$desktop_defines{$ver}});
	push (@versions_list, "_LSB$v");
}
printf $fd "#define LSB_All_Modules 0x%x\n\nextern int LSB_Desktop_Modules[];\n\n#endif\n", $count;
close($fd);
open($fd, ">modules.c");

print $fd q(/* GENERATED FILE, DO NOT MODIFY */
#include "modules.h"

);

print $fd "int LSB_Desktop_Modules[] = {LSB_Desktop_Modules".join(", LSB_Desktop_Modules", @versions_list)."};\n\n";

foreach (@lsbversions) {
	my $v = $_;
	$v =~ s/\.//g;
	print $fd "struct lsb_module LSB_Modules_LSB".$v."[] = {\n";

	print $fd "\t{\"LSB_All_Modules\",\tLSB_All_Modules},\n";
	print $fd "\t{\"LSB_Modules\",\tLSB_Desktop_Modules_LSB$v},\n";
	print $fd "\t{\"LSB_Core_Modules\",\tLSB_Core_Modules},\n";
	foreach my $row (sort keys %{$defines{$_}}) {
#		my $name = pop(@defines);
#		my $row = pop(@defines);
		print $fd "\t{\"$row\",\t".$defines{$_}->{$row}."},\n";
	}
	print $fd "\t{NULL, 0},\n};\n\n";
}

print $fd "struct lsb_module* LSB_Modules[] = {LSB_Modules".join(", LSB_Modules", @versions_list)."};\n";

close($fd);

$sth->finish;
$dbh->disconnect;
