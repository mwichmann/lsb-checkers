#!/usr/bin/perl

use CGI;
use DBI;
use Getopt::Long;

sub usage()
{
print STDERR "Usage: mkfunclist -v <lsbversion(s)>\n";
print STDERR "    LSB versions should be comma-separated.\n";
die;
}

GetOptions("v=s" => \$lsbversion);
if( !$lsbversion ) { usage(); }

use Env qw(LSBUSER LSBDBPASSWD LSBDB LSBDBHOST);

my $dbh = DBI->connect('DBI:mysql:database='.$LSBDB.';host='.$LSBDBHOST, $LSBUSER, $LSBDBPASSWD)
    or die "Couldn't connect to database: ".DBI->errstr;

$newerVersion_Q = $dbh->prepare("SELECT AIint FROM ArchInt WHERE AIint= ?  AND AIarch = ? AND AIappearedin > ? ")
    or die "Couldn't prepare 'newerVersion' query: ".DBI->errstr;

$nonGeneric_Q = $dbh->prepare("SELECT AIarch FROM ArchInt WHERE AIint = ?  AND AIarch > 1 LIMIT 1 ")
     or die "Couldn't prepare 'nonGeneric' query: ".DBI->errstr;

print "/* Generated file - Do Not Edit */\n";
print "#include \"elfchk.h\"\n\n";

@lsbversions = sort split(/,/, $lsbversion);
@lsbvernames = @lsbversions;
for ($i = 0; $i <= $#lsbvernames; $i++) {
    $lsbvernames[$i] =~ s/\.//g;
}

my %deprecated_submodules;
my %deprecated_libs;

# Create lists of deprecated entries
$select = "SELECT SMname, SMdeprecatedsince FROM SubModule WHERE SMdeprecatedsince > ''";
$sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
for (1..$sth->rows) {
    $entry = $sth->fetchrow_hashref or die "Fetchrow failed on $select query: ".DBI->errstr;
    $deprecated_submodules{$entry->{'SMname'}} = $entry->{'SMdeprecatedsince'};
}

$select = "SELECT Lid, Ldeprecatedsince FROM Library WHERE Ldeprecatedsince > ''";
$sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
for (1..$sth->rows) {
    $entry = $sth->fetchrow_hashref or die "Fetchrow failed on $select query: ".DBI->errstr;
    $deprecated_libs{$entry->{'Lid'}} = $entry->{'Ldeprecatedsince'};
}

sub createTmpTables($ )
{
    my ($ver) = shift;

    $create = "CREATE TEMPORARY TABLE tmp_IncludedLibGroups_$ver "
        . "(KEY `LGid`(`LGid`)) "
        . "SELECT DISTINCT LGid, Lid, SMname FROM Library "
        . "LEFT JOIN LibGroup ON LGlib=Lid "
        . "LEFT JOIN ArchLib ON ALlid=Lid "
        . "LEFT JOIN ModLib ON MLlid=Lid "
        . "LEFT JOIN SubModule ON MLmid=SMid "
        . "WHERE ALappearedin <= '$ver' AND ALappearedin > '' "
        . "AND (ALwithdrawnin IS NULL OR ALwithdrawnin > '$ver') "
        . "AND MLappearedin <= '$ver' AND MLappearedin > '' "
        . "AND (MLwithdrawnin IS NULL OR MLwithdrawnin > '$ver') ";
    $sth = $dbh->prepare($create) || die $dbh->errstr;
    $sth->execute() || die $sth->errstr;
}

foreach $ver (@lsbversions) {
    createTmpTables($ver);
    $select = "SELECT Iid,Iname,AIdeprecatedsince,AIappearedin,AIwithdrawnin,Vname,Asymbol,Aname,Aid,SMname,Lid FROM tmp_IncludedLibGroups_$ver ";
    $select.= "LEFT JOIN LGInt ON LGIlibg=LGid ";
    $select.= "LEFT JOIN Interface ON Iid=LGIint ";
    $select.= "LEFT JOIN ArchInt ON Iid=AIint ";
    $select.= "LEFT JOIN Architecture ON Aid=AIarch ";
    $select.= "LEFT JOIN Version ON Vid=AIversion ";
    $select.= "WHERE AIappearedin <= '$ver' AND AIappearedin > '' ";
    $select.= "AND (AIwithdrawnin IS NULL OR AIwithdrawnin > '$ver') ";
    $select.= "ORDER BY Iname,Aid,Vid ";

    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;

    my %processed;

    $suffix = "_LSB$ver";
    $suffix =~ s/\.//g;
    print "struct versym DynSyms".$suffix."[] = {\n";
    for (1..$sth->rows) {
        $entry = $sth->fetchrow_hashref or die "Fetchrow failed on $select query: ".DBI->errstr;

        if ($entry->{'AIwithdrawnin'}) {
            # Let's check if there is an interface with newer version
            $newerVersion_Q->execute( $entry->{'Iid'}, $entry->{'Aid'},
                          $entry->{'AIappearedin'} )
            or die "Couldn't execute 'newerVersion' query: ".DBI->errstr;

        if ($newerVersion_Q->rows) {
                next;
            }
        }

        # There can be several entries in the Interface table with the same name in the same module
        # (e.g. for Qt4 the same vtables in different libs)- skip them
        if ($processed{ ($entry->{'Aname'},$entry->{'Iname'},$entry->{'Vname'},$entry->{'SMname'}) }) {
            next;
        }
        $processed{ ($entry->{'Aname'},$entry->{'Iname'},$entry->{'Vname'},$entry->{'SMname'}) } = 1;

        if ($entry->{'Aname'} && $entry->{'Aname'} ne "All") {
            print "#if $entry->{'Asymbol'}\n";
        }
        elsif ($entry->{'Aname'} && $entry->{'Aname'} eq "All") {
            $nonGeneric_Q->execute($entry->{'Iid'}) or die "Couldn't execute 'nonGeneric' query: ".DBI->errstr;

            # Some architecture specific records found - don't check generic information
            if ($nonGeneric_Q->rows) {
                next;
            }
        }
        printf "\t{\"%s\",\"%s\",",$entry->{'Iname'},$entry->{'Vname'};
        if( ($entry->{'AIdeprecatedsince'} and $entry->{'AIdeprecatedsince'} le $ver)
            or (defined $deprecated_submodules{$entry->{'SMname'}} and $deprecated_submodules{$entry->{'SMname'}} le $ver)
            or (defined $deprecated_libs{$entry->{'Lid'}} and $deprecated_libs{$entry->{'Lid'}} le $ver) ) {
            printf "1";
        } else {
            printf "0";
        }
        printf ",%s",$entry->{'SMname'};
        printf "},\n";
        if ($entry->{'Aname'} && $entry->{'Aname'} ne "All") {
            print "#endif\n";
        }
    }
    print "};\n\n";
    print "int numDynSyms$suffix = sizeof(DynSyms$suffix)/sizeof(struct versym);\n\n";

    $sth->finish;
}

print "struct versym* DynSyms[] = {DynSyms_LSB".join(", DynSyms_LSB", @lsbvernames)."};\n";
print "int numDynSyms[] = {sizeof(DynSyms_LSB".join(")/sizeof(struct versym), sizeof(DynSyms_LSB", @lsbvernames).")/sizeof(struct versym)};\n";

$newerVersion_Q->finish();
$nonGeneric_Q->finish();
$dbh->disconnect;

