#!/usr/bin/perl

# Copyright (c) 2001-2006 The Free Standards Group Inc.

use DBI;
use Getopt::Long;

use Env qw(LSBUSER LSBDBPASSWD LSBDB LSBDBHOST);

sub usage()
{
print STDERR "mktests -v lsbversion [-m|--macros]\n";
die;
}

# Uncomment to trace SQL statments
#$trace=1;

# Don't check macros by default - the checks produce quite a few 
# false positives at the moment for macros that reference other macros
$check_macros=0;

GetOptions("v=s" => \$lsbversion, "m|macros!" => \$check_macros);
if( !$lsbversion ) { usage(); }

# Value for __LSB_VERSION__ (with dot dropped)
$printable_lsb_version = $lsbversion;
$printable_lsb_version =~ s/\.//;

# Index to distibguish function pointer arguments
$uniqFptrNum=0;

# Temporary workarounds so hand-edited changes aren't lost
# workaround for math functions that don't have protos on all architectures
@mathsyms = qw/__finitel __isinfl __isnanl acoshl acosl asinhl asinl atan2l atanhl atanl cbrtl ceill copysignl coshl cosl dreml erfcl erfl expl expm1l fabsl fdiml finitel floorl fmal fmaxl fminl fmodl frexpl gammal hypotl ilogbl j0l j1l jnl ldexpl lgammal lgammal_r llrintl llroundl log10l log1pl log2l logbl logl lrintl lroundl modfl nanl nearbyintl nextafterl nexttowardl pow10l powl remainderl remquol rintl roundl scalbl scalblnl scalbnl significandl sincosl sinhl sinl sqrtl tanhl tanl tgammal truncl y0l y1l ynl/;
$mathstring = "#if ! __powerpc__ && ! __s390__ /* hack */\n";

# counter used to calculate test number
$cnt = 0;

sub
getBaseTypeID($)
{
    local ($param) = @_;
    if( $$param{'ATbasetype'} != '' ) {
        $basetype = $$param{'ATbasetype'};
    }
    else {
        $selectBase = "SELECT ATbasetype FROM ArchType ";
        $selectBase.= "WHERE ATtid=".$$param{'Tid'}." ";
        $selectBase.= "GROUP BY ATbasetype";
        $sthBase = $dbh->prepare($selectBase)
            or die "Couldn't prepare $selectBase query: ".DBI->errstr;
        $sthBase->execute or die "Couldn't execute $selectBase query: ".DBI->errstr;
        if($sthBase->rows != 1) {
            die "Couldn't determine basetype for type ".$$param{'Tid'}." on $Aid architecture";
        }

        $base=$sthBase->fetchrow_hashref;
        $basetype = $base->{'ATbasetype'};
        $sthBase->finish;
    }

    return $basetype;
}

sub
getBaseTypeRecord($$)
{
    local ($basetype,$Aid) = @_;
    $select = "SELECT * FROM Type ";
    $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "WHERE Tid=".$basetype;
    $select.= " AND ATaid IN (1,$Aid,0)"; # Note that even if there is two records here only first will be processed
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    if( !$sth->rows ) {
        $sth->finish;
        # Hmm... Failed to get basetype on the current or generic architecture -
        #  let's try to get basetype on any architecture (not good practice, but it's a usual situation
        #  in the current db)
        $select = "SELECT * FROM Type ";
        $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $select.= "WHERE Tid=".$basetype;
        $select.= " GROUP BY ATtid ";
        $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    }
    return $sth;
}

# For a given type, check if there are architecture specific records
# in the ArchType table. If not, return -1. Otherwise, check if records
# for every supported architecture present; if not, print appropriate
# 'Msg' calls and return number of missed archs, otherwise return 0
sub checkArchSpecific($$$$) {
    local ($Tname,$Tid,$condition,$Ttype) = @_;
    local %PresentedArchs;

    $selectArchSpecific = "SELECT * FROM Type LEFT JOIN ArchType ON ATtid=Tid ";
    $selectArchSpecific.= "WHERE ATaid<>1 ";
    $selectArchSpecific.= "AND ATtid=$Tid ";
    $selectArchSpecific.= "AND ( ATappearedin<>'' AND ATappearedin<='$lsbversion' ";
    $selectArchSpecific.= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin > '$lsbversion') ) ";
    $sth = $dbh->prepare($selectArchSpecific) or die "Couldn't prepare $selectArchSpecific query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $selectArchSpecific query: ".DBI->errstr;

    $archNumber = $sth->rows;
    if( $archNumber == 0 ) {
        $sth->finish;
        return -1;
    }

    for ( 1 .. $archNumber ) {
        $archentry = $sth->fetchrow_hashref;
        $PresentedArchs{$archentry->{'ATaid'}} = 1;
    }
    $sth->finish;

    # Get history info for generic record - required in cases when we want
    # to display "REPLACE INTO ArchType" warnings
    $selectGenericHistory = "SELECT * FROM ArchType ";
    $selectGenericHistory.= "WHERE ATaid=1 ";
    $selectGenericHistory.= "AND ATtid=$Tid ";
    $selectGenericHistory.= "AND ( ATappearedin<>'' AND ATappearedin<='$lsbversion' ";
    $selectGenericHistory.= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin > '$lsbversion') ) ";
    $sthGeneric = $dbh->prepare($selectGenericHistory) or die "Couldn't prepare $selectGenericHistory query: ".DBI->errstr;
    $sthGeneric->execute or die "Couldn't execute $selectGenericHistory query: ".DBI->errstr;
    $genentry = $sthGeneric->fetchrow_hashref;
    $appearedin  = $genentry->{'ATappearedin'};
    $basetype    = $genentry->{'ATbasetype'};
    $withdrawnin = $genentry->{'ATwithdrawnin'} ? "'\"\"$genentry->{'ATwithdrawnin'}\"\"'" : "NULL";
    $attribute   = $genentry->{'ATattribute'} ? "'\"\"$genentry->{'ATattribute'}\"\"'" : "NULL";

    # Get all supported architectures;
    $selectAllArchs = "SELECT Aid,Asymbol FROM Architecture WHERE Aid<>1";
    $ath = $dbh->prepare($selectAllArchs) or die "Couldn't prepare $selectAllArchs query: ".DBI->errstr;
    $ath->execute or die "Couldn't execute $selectAllArchs query: ".DBI->errstr;

    $allNum = $ath->rows;

    if( ($Tname !~ /anon/ or $Ttype eq 'Enum') and ($Tname !~ /fptr/) ) {
        if( $allNum > $archNumber ) {
            $missedCount=0;
            for ( 1 .. $allNum ) {
                @aentry = $ath->fetchrow_array;
                if( not $PresentedArchs{$aentry[0]} ) {
                    if( $missedCount ) {
                        print TESTS "#elif $aentry[1]\n";
                    }
                    else {
                        if( $condition eq "endif" ) {
                            print TESTS "#endif\n\n";
                            print TESTS "#if $aentry[1]\n";
                        }
                        elsif( $condition eq "elif" ) {
                            print TESTS "#elif $aentry[1]\n";
                        }
                        elsif( $condition eq "if" ) {
                            print TESTS "#if $aentry[1]\n";
                        }
                        else {
                            die "Illegal condition was passed to checkArchSpecific";
                        }
                    }

                    print TESTS "Msg(\"Find size of $Tname ($Tid)\\n\");\n";

                    print TESTS "Sql(\"REPLACE INTO ArchType VALUES (";
                    print TESTS "%d,%d,%d,'\"\"$appearedin\"\"',$withdrawnin,$basetype,$attribute);\\n\",architecture,$Tid,0);\n";
                    $missedCount++;
                }
            }
        }
    }
    $ath->finish;
    $sthGeneric->finish;

    return $missedCount;
}

sub displaytyperef($$$) {
    local ( $param, $enableConst, $curArch ) = @_;
    local ( %select, $sth, $type );

    if (   $$param{'Ttype'} eq "Volatile"
        || $$param{'Ttype'} eq "Intrinsic"
        || $$param{'Ttype'} eq "Literal" )
    {
        print TESTS $$param{'Tname'};
        return;
    }

    if ( $$param{'Ttype'} eq "Const" ) {
        $basetype = getBaseTypeID($param);
        $sth = getBaseTypeRecord($basetype,$curArch);
        $type = $sth->fetchrow_hashref;
        $sth->finish;
        if ( $type->{'Ttype'} eq "Pointer" ) {
            displaytyperef( $type, $enableConst, $curArch );
            print TESTS "const " if $enableConst;
        } else {
            print TESTS "const " if $enableConst;
            displaytyperef( $type, $enableConst, $curArch );
        }
        return;
    }

    if ( $$param{'Ttype'} eq "Pointer" ) {
        $basetype = getBaseTypeID($param);
        $sth = getBaseTypeRecord($basetype,$curArch);
        $type = $sth->fetchrow_hashref;
        $sth->finish;
        displaytyperef( $type, $enableConst, $curArch );
        print TESTS " *";
        return;
    }

    if ( $$param{Tname} =~ "anon" ) {
        $$param{Tname} = "";
    }

    if ( $$param{'Ttype'} eq "Struct" ) {
        print TESTS "struct " . $$param{'Tname'};
        return;
    }

    if ( $$param{'Ttype'} eq "Typedef" ) {
        print TESTS $$param{'Tname'};
        return;
    }

    if ( $$param{'Ttype'} eq "Union" ) {
        print TESTS "union " . $$param{'Tname'};
        return;
    }

    if ( $$param{'Ttype'} eq "Enum" ) {
        print TESTS "enum ".$$param{'Tname'};
        return;
    }

    if ( $$param{'Ttype'} eq "Array" ) {
        $basetype = getBaseTypeID($param);
        $sth = getBaseTypeRecord($basetype,$curArch);
        $type = $sth->fetchrow_hashref;
        $sth->finish;
        if ( !$nameonly ) {
            #$nameonly=1;
            displaytyperef( $type, $enableConst, $curArch );
            #$nameonly=0;
        } else {
            displaytyperef( $type, $enableConst, $curArch );
        }
        return;
    }

    if ( $$param{'Ttype'} eq "FuncPtr" ) {
        $basetype = getBaseTypeID($param);
        $sth = getBaseTypeRecord($basetype,$curArch);
        $type = $sth->fetchrow_hashref;
        $sth->finish;
        $Tid    = $$param{'Tid'};
        displaytyperef( $type, $enableConst, $curArch );
        print TESTS "(*";
        if( $$param{'Ttype'} eq 'FuncPtr' ) {
            $$param{'Tname'} = "fptr".$uniqFptrNum;
            $uniqFptrNum++;
        }
#       if( $$param{'Tname'} =~ /fptr\-\d+\s/ ) {
#           $$param{'Tname'} = "fptr";
#       }
#       elsif( $$param{'Tname'} =~ "fptr" ) {
#           $$param{'Tname'} =~ s/fptr-//;
#       }
        print TESTS $$param{'Tname'};
        print TESTS ")";

        print TESTS "(";

        $tmselect = "SELECT * FROM TypeMember";
        $tmselect .= " WHERE TMmemberof=$Tid AND TMaid in(1,$curArch)";
        $tmselect .= " AND TMappearedin > '' AND TMappearedin <= '$lsbversion'";
        $tmselect .= " AND (TMwithdrawnin IS NULL OR TMwithdrawnin > '$lsbversion')";
        $tmselect .= " GROUP BY TMid";
        $tmselect .= " ORDER BY TMposition";
        $tmh = $dbh->prepare($tmselect) or die "Couldn't prepare $tmselect query: ".DBI->errstr;
        $tmh->execute or die "Couldn't execute $tmselect query: ".DBI->errstr;
        if ( $tmh->rows == 0 ) {
            print TESTS "void";
        }
        for ( 1 .. $tmh->rows ) {
            $tmentry  = $tmh->fetchrow_hashref;
            $TMtypeid = $tmentry->{'TMtypeid'};
            $tselect  = "SELECT * FROM Type";
            $tselect .= " LEFT JOIN ArchType ON ATaid=$curArch AND ATtid=Tid";
            $tselect .= " WHERE Tid=$TMtypeid";
            $th = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
            $th->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
            $thentry = $th->fetchrow_hashref;
            $th->finish;

            #$nameonly=1;
            displaytyperef( $thentry, $enableConst, $curArch );

            #print TESTS $tmentry->{'TMname'};
            if ( $thentry->{'Ttype'} eq 'Array' ) {
                print TESTS "[" . $thentry->{'ATsize'} . "]";
            }
            if ( $_ != $tmh->rows ) {
                print TESTS ",";
            }

            #$nameonly=0;
        }
        $tmh->finish;

        print TESTS ")\n";

        return;
    }

    if( $$param{'Ttype'} ) {
    print TESTS $$param{'Ttype'};
    }
    else {
        print TESTS $$param{'Tname'};
    }
}

sub writetest($$) {
    local ( $Hid, $Hname ) = @_;
    local ($lastid, $lastaid);
    my ($entry);

    # Get Constants
    $select = "SELECT DISTINCT * FROM Constant ";
    $select .= "INNER JOIN HeaderGroup on CHeadgroup=HGid ";
    $select .= "LEFT JOIN ArchConst ON ACcid=Cid ";
    $select .= "LEFT JOIN Architecture ON Aid=ACaid ";
    $select .= "WHERE HGheader=$Hid ";
    $select.= "AND (ACappearedin is not NULL and ACappearedin <= '$lsbversion' and ACappearedin<>'') ";
    $select.= "AND (ACwithdrawnin IS NULL OR ACwithdrawnin > '$lsbversion') ";
    $select .= "ORDER BY Cheadgroup,Cname,ACvalue ";
    $cth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $cth->execute or die "Couldn't execute $select query: ".DBI->errstr;

    # Get Types
    $select = "SELECT DISTINCT * FROM Type ";
    $select .= "INNER JOIN HeaderGroup ON Theadgroup=HGid ";
    $select .= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select .= "LEFT JOIN Architecture ON Aid=ATaid ";
    $select .= "WHERE HGheader=$Hid ";
    $select.= "AND ( ( ATappearedin <= '$lsbversion' AND ATappearedin >''  ";
    $select.= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin >'$lsbversion') ) ";
    $select.= "OR ( Ttype IN ('Struct','Union') ";
    $select.= "AND Tid IN ( ";
    $select.= " SELECT DISTINCT TMmemberof FROM TypeMember ";
    $select .= " WHERE TMappearedin > '' AND TMappearedin <= '$lsbversion'";
    $select .= " AND (TMwithdrawnin IS NULL OR TMwithdrawnin > '$lsbversion')";
    $select.= ") ";
    $select.= "AND Tid IN ( ";
    $select.= " SELECT ATbasetype FROM Type ";
    $select.= "  JOIN HeaderGroup ON Theadgroup=HGid";
    $select.= "  LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "  WHERE HGheader=$Hid";
    $select.= "  AND Ttype='Typedef' ";
    $select.= "  AND ATappearedin <= '$lsbversion' AND ATappearedin > ''  ";
    $select.= "  AND (ATwithdrawnin IS NULL OR ATwithdrawnin >'$lsbversion')  ";
    $select.= ") ) )";
    $select .= "ORDER BY Theadgroup,Tid, Aid DESC ";
    $tth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $tth->execute or die "Couldn't execute $select query: ".DBI->errstr;

    # Get Interfaces
    $select = "SELECT * FROM Interface ";
    $select .= "LEFT JOIN Type ON Ireturn=Tid ";
    $select .= "LEFT JOIN ArchInt ON Iid=AIint ";
    $select .= "LEFT JOIN ArchType ON ATtid=Tid AND ATaid=AIarch ";
    $select .= "LEFT JOIN Architecture ON AIarch=Aid ";
    $select .= "WHERE Isrcbin='Both' ";
    $select .= "AND Iheader=$Hid ";
    $select .= "AND Itype IN ('Function','Data') ";
    $select .= "AND Iclass = 0 ";
    $select .= "AND AIappearedin <= '$lsbversion' AND AIappearedin > '' ";
    $select .= "AND (AIwithdrawnin IS NULL OR AIwithdrawnin >'$lsbversion') ";
    print $select, "\n" if $trace;
    $ith = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $ith->execute or die "Couldn't execute $select query: ".DBI->errstr;

    $fname = $Hname;
    $fname =~ tr/\/.-/__/;

    # Try to guess if we have a cpp header
    $select = "SELECT * FROM Type ";
    $select.= "LEFT JOIN HeaderGroup ON Theadgroup=HGid ";
    $select.= "WHERE HGheader=$Hid ";
    $select.= "AND (Ttype='Class' OR Ttype='TemplateInstance' OR Tclass>0) ";
    $select.= "LIMIT 1";
    $classth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $classth->execute or die "Couldn't execute $select query: ".DBI->errstr;

    if( $classth->rows ) {
        $filename = $fname . ".C";
    }
    else {
        $filename = $fname . ".c";
    }
    $objname  = $fname . ".o";
    $classth->finish;

    open( TESTS, ">$filename" ) || die "Can't open $filename for writing";
    print "Writing tests for $Hname to $filename\n";

    if ( $cth->rows == 0 && $tth->rows == 0 && $ith->rows == 0 ) {
        print "No type tests to write for $Hname\n";
        print TESTS "/*\n * No values in $Hname\n */\n";
        close(TESTS);
        $cth->finish;
        $tth->finish;
        $ith->finish;
        return;
    }

    print MAKEFILE "\\\n\t$objname ";
    print HARNESS "tcnt+=$fname();\n";
    print SUBDEFS "extern void $fname();\n";
    $cnt++;
    print TET_HDR "\t{ $fname, $cnt },\n";

    print TESTS "/*\n * Test of $Hname\n */\n";
    print TESTS "#include \"hdrchk.h\"\n";
    if( $Hname ne 'stdio.h' ) {
        print TESTS "#include \<stdio.h\>\n";
    }
    if( $Hname ne 'stdlib.h' ) {
    print TESTS "#include \<stdlib.h\>\n";
    }
    if( $Hname ne 'string.h' ) {
    print TESTS "#include \<string.h\>\n";
    }
    print TESTS "#include \<sys/types.h\>\n";
    print TESTS "#define _LSB_DEFAULT_ARCH 1\n";
    print TESTS "#define __LSB_VERSION__ $printable_lsb_version\n";

    open( INCS, "<$fname.inc" );
    while (<INCS>) {
        print TESTS $_;
    }
    close(INCS);
    print TESTS "#include \"$Hname\"\n";
    print TESTS "\n\n\n";
    print TESTS "#ifdef TET_TEST\n";
    print TESTS "void $fname()\n{\n";
    print TESTS "#else\n";
    print TESTS "int $fname()\n{\n";
    print TESTS "#endif\n\n";
    print TESTS "int cnt=0;\n\n";
    print TESTS "int pcnt=0;\n";
    print TESTS "char *real_macro_value, *stripped_macro_value;\n";
    print TESTS "int macro_ndx, stripped_value_ndx;\n";
    print TESTS "real_macro_value=(char*)malloc( (MAX_VALUE_LENGTH+1)*sizeof(char) );\n";
    print TESTS "stripped_macro_value=(char*)malloc( (MAX_VALUE_LENGTH+1)*sizeof(char) );\n\n";
    print TESTS "Msg(\"Checking data structures in $Hname\\n\");\n";

    my (%constHash);
    for ( 1 .. $cth->rows ) {
        my ($centry);
        $centry = $cth->fetchrow_hashref;
        $constHash{ $centry->{'Cid'} }{ $centry->{'Aid'} } = $centry;
    }
    $cth->finish;

    foreach $cid ( sort keys %constHash ) {
        $archCount = 0;
        foreach $archId ( reverse sort keys %{ $constHash{$cid} } ) {
            %centry    = %{ $constHash{$cid}{$archId} };
            $cname_save   = $centry{'Cname'};
            $type_save  = $centry{'Ctype'};
            $cid_save    = $centry{'Cid'};
            $cappearedin  = $centry{'ACappearedin'};
            $cwithdrawnin = $centry{'ACwithdrawnin'};

            $withdrawnin   = $cwithdrawnin ? "'\"\"$cwithdrawnin\"\"'" : "NULL";
            if ( $centry{'Aid'} == 1 ) {
                $centry{Asymbol} = "_LSB_DEFAULT_ARCH";
            }
            if ( $archCount == 0 ) {
                print TESTS "#if $centry{Asymbol}\n";
            } else {
                print TESTS "#elif $centry{Asymbol}\n";
            }
            $archCount++;

            if ( $centry{'Ctype'} eq 'int' ) {
                print TESTS "#ifdef $centry{'Cname'}\n";
                print TESTS "\tCompareConstant($centry{'Cname'},$centry{'ACvalue'},$centry{'Cid'},architecture,$cappearedin,$withdrawnin)\n";
                print TESTS "#else\n";
                print TESTS "Msg( \"Error: Constant not found: $centry{'Cname'}\\n\");\n";
                print TESTS "cnt++;\n";
                print TESTS "#endif\n\n";
            } elsif ( $centry{'Ctype'} eq 'long' ) {
                print TESTS "#ifdef $centry{'Cname'}\n";
                print TESTS "\tCompareLongConstant($centry{'Cname'},$centry{'ACvalue'},$centry{'Cid'},architecture,$cappearedin,$withdrawnin)\n";
                print TESTS "#else\n";
                print TESTS "Msg( \"Error: Constant not found: $centry{'Cname'}\\n\");\n";
                print TESTS "cnt++;\n";
                print TESTS "#endif\n\n";
            } elsif ( $centry{'Ctype'} eq 'float' ) {
                print TESTS "#ifdef $centry{'Cname'}\n";
                print TESTS "\tCompareFloatConstant($centry{'Cname'},$centry{'ACvalue'},$centry{'Cid'},architecture,$cappearedin,$withdrawnin)\n";
                print TESTS "#else\n";
                print TESTS "Msg( \"Error: Constant not found: $centry{'Cname'}\\n\");\n";
                print TESTS "cnt++;\n";
                print TESTS "#endif\n\n";
            } elsif ( $centry{'Ctype'} eq 'double' ) {
                print TESTS "#ifdef $centry{'Cname'}\n";
                print TESTS "\tCompareDoubleConstant($centry{'Cname'},$centry{'ACvalue'},$centry{'Cid'},architecture,$cappearedin,$withdrawnin)\n";
                print TESTS "#else\n";
                print TESTS "Msg( \"Error: Constant not found: $centry{'Cname'}\\n\");\n";
                print TESTS "cnt++;\n";
                print TESTS "#endif\n\n";
            } elsif ( $centry{'Ctype'} eq 'longdouble' ) {
                print TESTS "#ifdef $centry{'Cname'}\n";
                print TESTS "\tCompareLongDoubleConstant($centry{'Cname'},$centry{'ACvalue'},$centry{'Cid'},architecture,$cappearedin,$withdrawnin)\n";
                print TESTS "#else\n";
                print TESTS "Msg( \"Error: Constant not found: $centry{'Cname'}\\n\");\n";
                print TESTS "cnt++;\n";
                print TESTS "#endif\n\n";
            } elsif ( $centry{'Ctype'} eq 'string' ) {
                print TESTS "#ifdef $centry{'Cname'}\n";
                print TESTS "\tCompareStringConstant($centry{'Cname'},\""
                  . $centry{'ACvalue'} . "\",$centry{'Cid'},architecture,$cappearedin,$withdrawnin)\n";
                print TESTS "#else\n";
                print TESTS "Msg( \"Error: Constant not found: $centry{'Cname'}\\n\");\n";
                print TESTS "cnt++;\n";
                print TESTS "#endif\n\n";
            } elsif ( $centry{'Ctype'} eq 'protector' or $centry{'Ctype'} eq 'flag' ) {
                print TESTS "#ifndef $centry{'Cname'}\n";
                print TESTS "Msg( \"Error: Constant not found: $centry{'Cname'}\\n\");\n";
                print TESTS "cnt++;\n";
                print TESTS "#endif\n\n";
            } elsif ( $centry{'Ctype'} eq 'accessor' ) {
                print TESTS "#ifdef $centry{'Cname'}\n";
                print TESTS "\tCompareMacro($centry{'Cname'},$centry{'ACvalue'},$centry{'ACvalue'},$centry{'Cid'},architecture,$cappearedin,$withdrawnin)\n";
                print TESTS "#else\n";
                print TESTS "Msg( \"Error: Constant not found: $centry{'Cname'}\\n\");\n";
                print TESTS "cnt++;\n";
                print TESTS "#endif\n\n";
            } elsif ( $centry{'Ctype'} eq 'literal' and $centry{'ACvalue'} !~ /,|\)|\(/ ) {
                # We can tests some literals as macros, but only if they
                # don't contain commas or braces
                print TESTS "#ifdef $centry{'Cname'}\n";
                print TESTS "\tCompareMacro($centry{'Cname'},$centry{'ACvalue'},$centry{'ACvalue'},$centry{'Cid'},architecture,$cappearedin,$withdrawnin)\n";
                print TESTS "#else\n";
                print TESTS "Msg( \"Error: Constant not found: $centry{'Cname'}\\n\");\n";
                print TESTS "cnt++;\n";
                print TESTS "#endif\n\n";
            } elsif ( $centry{'Ctype'} eq 'macro' and $check_macros ) {
                if( $centry{'Cname'} =~ /(.+)\(/ ) {
                    $short_name = $1;
                }
                else {
                    $short_name = $centry{'Cname'};
                }

                print TESTS "#ifdef $short_name\n";
        # Check if the macro value has a comma not inside brackets; we can't check such macros yet
        $opened_brackets=0;
        $can_test = 1;
        foreach my $char (split //, $centry{'ACvalue'}) {
            if( $char eq "(" ) {
            $opened_brackets++;
            }
            elsif( $char eq ")" ) {
            $opened_brackets--;
            }
            elsif( $char eq "," and $opened_brackets == 0 ) {
            $can_test=0;
            last;
            }
        }

        if( $can_test ) {
            $value = $centry{'ACvalue'};
                    $value =~ s/\\//g;
                    $value =~ s/\s//g;
                    print TESTS "\tCompareMacro($centry{'Cname'},$value,$centry{'ACvalue'},$centry{'Cid'},architecture,$cappearedin,$withdrawnin)\n";
        }
        else {
            print TESTS "/* Can't check macro value */\n";
        }
            print TESTS "#else\n";
                print TESTS "Msg( \"Error: Constant not found: $centry{'Cname'}\\n\");\n";
                print TESTS "cnt++;\n";
                print TESTS "#endif\n\n";
            } else {
                print TESTS "/* No test for $centry{'Cname'} */\n";
            }
        }
        if ( exists( $constHash{$cid}{1} ) ) {
            print TESTS "#endif\n\n";
        } else {
            print TESTS "#else\n";
            print TESTS "Msg( \"No definition for $cname_save ($cid_save, $type_save) in db for this architecture\\n\");\n";
            print TESTS "#ifdef $cname_save\n";
            if ( $type_save eq 'int' ) {
                print TESTS "Sql( \"REPLACE INTO ArchConst (ACaid,ACcid,ACvalue,ACappearedin,ACwithdrawnin) VALUES (%d,$cid_save,%d,'\"\"$cappearedin\"\"',$withdrawnin);\\n\", architecture, $cname_save);\n";
            }
            if ( $type_save eq 'long' ) {
                print TESTS "Sql( \"REPLACE INTO ArchConst (ACaid,ACcid,ACvalue,ACappearedin,ACwithdrawnin) VALUES (%d,$cid_save,%ld,'\"\"$cappearedin\"\"',$withdrawnin);\\n\", architecture, $cname_save);\n";
            }
            if ( $type_save eq 'string' ) {
                print TESTS "Sql( \"REPLACE INTO ArchConst (ACaid,ACcid,ACvalue,ACappearedin,ACwithdrawnin) VALUES (%d,$cid_save,%s,'\"\"$cappearedin\"\"',$withdrawnin);\\n\", architecture, $cname_save);\n";
            }
            print TESTS "#endif\n";
            print TESTS "#endif\n";
        }
    }

    $lastid = 0;
    $lastaid = 0;
    $total_printed = 0;
    for ( 1 .. $tth->rows ) {
        $tentry = $tth->fetchrow_hashref;
        if ( !$tentry->{'Asymbol'} )   {
            print STDERR "Type " . $tentry->{'Tname'} . " is missing Arch\n";
            $tentry->{'Asymbol'} = '__no_sym__';
        }

        $condition = "elif"; # "elif"
        if ( $tentry->{'Tid'} != $lastid ) {
            if ( $lastid != 0 ) {
                $condition = "endif";
            }
            else {
            $condition = "if";
        }
        }

        if( $tentry->{'Aid'} == 1 ) {
            $printedMsgs = checkArchSpecific($tentry->{'Tname'},$tentry->{'Tid'},$condition,$tentry->{'Ttype'});
            if( $printedMsgs > 0 ) {
                $lastid = $tentry->{'Tid'};
            }
            if( $printedMsgs != -1 ) {
                next;
            }
        }

        $idchanged = 0;

        # Do this before we reset the value, so we can re-use the values
        # from the last time through the loop if we need them
        if ( $tentry->{'Tid'} != $lastid ) {
            if( $lastid and $total_printed and ( ( $Tname !~ /anon/ or $Ttype eq 'Enum') and ( $Tname !~ /fptr/ ) ) ) {
                # We have output at least one type, and now we need to
                # put a catchall else clause
                if ( $lastaid != 1 ) {
                    $selectGeneric = "SELECT count(*) as cnt FROM ArchType ";
                    $selectGeneric.= "WHERE ATtid=$Tid AND ATaid=1 ";
                    $selectGeneric.= "AND ATappearedin<>'' AND ATappearedin <= '$lsbversion' ";
                    $selectGeneric.= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin > '$lsbversion') ";
                    $gth = $dbh->prepare($selectGeneric) or die "Couldn't prepare $selectGeneric query: ".DBI->errstr;
                    $gth->execute or die "Couldn't execute $selectGeneric query: ".DBI->errstr;
                    $gentry = $gth->fetchrow_hashref;
                    $gth->finish;
                    if ($gentry->{'cnt'} > 0) {
                        print TESTS "#else\n";
                        print TESTS "Msg(\"Find size of $Tname ($Tid)\\n\");\n";
                        $withdrawnin = $ATwithdrawnin ? "'\"\"$ATwithdrawnin\"\"'" : "NULL";
                        $attribute = $ATattribute ? "'\"\"$ATattribute\"\"'" : "NULL";
                        print TESTS "Sql(\"REPLACE INTO ArchType VALUES (";
                        print TESTS "%d,%d,%d,'\"\"$ATappearedin\"\"',$withdrawnin,$ATbasetype,$attribute);\\n\",architecture,$Tid,0);\n";
                    }
                }
                print TESTS "#endif\n\n";
            }
            $idchanged = 1;
            $total_printed = 0;

            if( ( $tentry->{'Tname'} !~ /anon/ or $tentry->{'Ttype'} eq 'Enum' ) and ( $tentry->{'Tname'} !~ /fptr/ ) and ( $tentry->{'Ttype'} ne 'Typedef' ) ) {
                print TESTS "#if $tentry->{'Asymbol'}\n";
                $total_printed++;
            }
        } else {
            if( ( $tentry->{'Tname'} !~ /anon/ or $tentry->{'Ttype'} eq 'Enum' ) and ( $tentry->{'Tname'} !~ /fptr/ ) and ( $tentry->{'Ttype'} ne 'Typedef' ) ) {
                print TESTS "#elif $tentry->{'Asymbol'}\n";
                $total_printed++;
            }
        }
        $lastid   = $tentry->{'Tid'};
        $lastaid  = $tentry->{'Aid'};
        $Tid      = $tentry->{'Tid'};
        $Tname  = $tentry->{'Tunmangled'} ? $tentry->{'Tunmangled'} : $tentry->{'Tname'};
        $Ttype  = $tentry->{'Ttype'};
        $ATsize   = $tentry->{'ATsize'};
        $Aid      = $tentry->{'Aid'};
        $Asymbol  = $tentry->{'Asymbol'};
        $Aname  = $tentry->{'Aname'};
        $ATappearedin  = $tentry->{'ATappearedin'};
        $ATwithdrawnin = $tentry->{'ATwithdrawnin'};
        $ATbasetype = $tentry->{'ATbasetype'};
        $ATattribute   = $tentry->{'ATattribute'};
        if ( $Tname =~ /anon/ && $tentry->{'Ttype'} ne 'Enum' ) { next; }
        if ( $Tname =~ /fptr/ ) { next; }

        #switch( $tentry->{'Ttype'}
        #case Struct:
        #case Union:
        if ( $tentry->{'Ttype'} eq 'Struct' || $tentry->{'Ttype'} eq 'Union' ) {
            if ( $tentry->{'Ttype'} eq 'Struct' ) {
                $type = "struct";
            } else {
                $type = "union";
            }

            $tselect = "SELECT * FROM Type ";
            $tselect .= "LEFT JOIN ArchType ON ATtid=Tid ";
            $tselect .= "LEFT JOIN Architecture ON Aid=ATaid ";
            $tselect .= "WHERE (ATappearedin <> '' AND ATappearedin <= '$lsbversion' ";
            $tselect .= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin > '$lsbversion') ) ";
            $tselect .= "AND Tid=" . $tentry->{'ATbasetype'};
            print $tselect, "\n" if $trace;
            $ttth = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
            $ttth->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
            $ttentry = $ttth->fetchrow_hashref;
            $ttth->finish;
            if( $ttentry->{'Tid'} or ($tentry->{'ATbasetype'} == 0) ) {
                $withdrawnin = $ATwithdrawnin ? "'$ATwithdrawnin'" : "NULL";
                $attribute = $ATattribute ? "'$ATattribute'" : "NULL";
                print TESTS "CheckTypeSize($type $Tname,$ATsize, $Tid, $Aid, $ATappearedin, $withdrawnin, $ATbasetype, $attribute)\n";
            }
            else {
                next; # do not check members of not included types
            }

            # Get the members
            if( $Aid ) {
                $select = "SELECT DISTINCT * FROM TypeMember ";
                $select .= "LEFT JOIN TypeMemberExtras ON TMEtmid=TMid ";
                $select .= "WHERE TMmemberof=$Tid AND TMaid in (1,$Aid) ";
                $select .= "AND TMappearedin > '' AND TMappearedin <= '$lsbversion' ";
                $select .= "AND (TMwithdrawnin IS NULL OR TMwithdrawnin > '$lsbversion') ";
                $select .= "AND TMbitfield = 0 ";
                $select .= "AND TMEaid=$Aid ";
                $select .= "AND TMEreserved='No' ";
                $select .= "AND TMname > '' ";
                $select .= "ORDER BY TMposition ";
                print $select, "\n" if $trace;
                $mth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
                $mth->execute or die "Couldn't execute $select query: ".DBI->errstr;
            }

            if ( $mth->rows ) {
                for ( 1 .. $mth->rows ) {
                    $mentry = $mth->fetchrow_hashref;

                    # XXXSTU - We really should fetch the info for the member
                    # type so we can validate the size in the DB
                    #
                    print TESTS "CheckMemberSize($type $tentry->{'Tname'},$mentry->{'TMname'},$mentry->{'TMEsize'},$Aid,$mentry->{'TMid'})\n";
                    print TESTS "CheckOffset($type $tentry->{'Tname'},$mentry->{'TMname'},$mentry->{'TMEoffset'},$Aid,$mentry->{'TMid'})\n";
                }
            } else {
                #Checking Structure Member Bit-Field value
                $select = "SELECT DISTINCT * FROM TypeMember ";
                $select .= "WHERE TMmemberof=$Tid AND TMaid in (1,$Aid) ";
                $select .= "AND TMappearedin > '' AND TMappearedin <= '$lsbversion' ";
                $select .= "AND (TMwithdrawnin IS NULL OR TMwithdrawnin > '$lsbversion') ";
                $select .= "AND TMbitfield > 0 ";
                $select .= "ORDER BY TMposition ";
                print $select, "\n" if $trace;
                $mth->finish;
                $mth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
                $mth->execute or die "Couldn't execute $select query: ".DBI->errstr;
                if($mth->rows){
                    for ( 1 .. $mth->rows ) {
                        $mentry = $mth->fetchrow_hashref;
                        print TESTS "CheckBitField($type $tentry->{'Tname'},$mentry->{'TMname'},$mentry->{'TMbitfield'},$Aid,$mentry->{'TMid'})\n";
                    }
                }else{
                    # Get the members that are supposed to be there
                    $select = "SELECT DISTINCT * FROM TypeMember ";
                    $select .= "LEFT JOIN TypeMemberExtras ON TMEtmid=TMid ";
                    $select .= "WHERE TMmemberof=$Tid AND TMaid in (1,$Aid) ";
                    $select .= "AND TMappearedin > '' AND TMappearedin <= '$lsbversion' ";
                    $select .= "AND (TMwithdrawnin IS NULL OR TMwithdrawnin > '$lsbversion') ";
                    $select .= "AND TMbitfield = 0 ";
                    $select .= "AND TMname > '' ";
                    $select .= "AND ( TMEaid IS NULL OR (TMEaid=$Aid ";
                    $select .= "AND TMEreserved='No') )";
                    $select .= "ORDER BY TMposition ";
                    print $select, "\n" if $trace;
                    $mth->finish;
                    $mth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
                    $mth->execute or die "Couldn't execute $select query: ".DBI->errstr;
                    print TESTS "Msg(\"Missing member data for $Tname on $Aname\\n\");\n";
                    for ( 1 .. $mth->rows ) {
                        $mentry = $mth->fetchrow_hashref;
                        print TESTS "CheckOffset($type $tentry->{'Tname'},$mentry->{'TMname'},0,$Aid,$mentry->{'TMid'})\n";
                    }
                }
            }
            $mth->finish;
            next;
        }

        #case Pointer:
        if ( $tentry->{'Ttype'} eq 'Pointer' ) {

            # need to get the basetype first
            $tselect = "SELECT * FROM Type ";
            $tselect .= "LEFT JOIN ArchType ON ATtid=Tid ";
            $tselect .= "LEFT JOIN Architecture ON Aid=ATaid ";
            $tselect .= "WHERE Tid=" . $tentry->{'ATbasetype'};
            print $tselect, "\n" if $trace;
            $ttth = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
            $ttth->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
            $ttentry = $ttth->fetchrow_hashref;
            $ttth->finish;
            my $typeName;

            $withdrawnin = $ATwithdrawnin ? "'$ATwithdrawnin'" : "NULL";
            $attribute = $ATattribute ? "'$ATattribute'" : "NULL";
            if ( $ttentry->{'Ttype'} eq 'Struct' ) {
                $typeName = "struct " . $Tname;
                print TESTS "CheckTypeSize($typeName,$ATsize, $Tid, $Aid, $ATappearedin, $withdrawnin, $ATbasetype, $attribute)\n";
            } elsif ( $ttentry->{'Ttype'} eq 'Union' ) {
                $typeName = "union " . $Tname;
                print TESTS "CheckTypeSize($typeName,$ATsize, $Tid, $Aid, $ATappearedin, $withdrawnin, $ATbasetype, $attribute)\n";
            } elsif ( $ttentry->{'Ttype'} eq 'Typedef' ) {
                print TESTS "CheckTypeSize($Tname,$ATsize, $Tid, $Aid, $ATappearedin, $withdrawnin, $ATbasetype, $attribute)\n";
            }
            next;
        }

        #case Enum:
        if ( $tentry->{'Ttype'} eq 'Enum' ) {
            $tmselect = "SELECT * FROM TypeMember ";
            $tmselect .= "WHERE TMmemberof=" . $tentry->{'Tid'};
            $tmselect .= " AND TMaid in (1,$Aid) ";
            $tmselect .= " AND TMappearedin > '' AND TMappearedin <= '$lsbversion'  ";
            $tmselect .= " AND (TMwithdrawnin IS NULL OR TMwithdrawnin > '$lsbversion') ";
            $tmselect .= " AND TMaid in (1,$Aid) ";
            $tmselect .= " ORDER BY TMposition";
            print $tmselect, "\n" if $trace;
            $tmh = $dbh->prepare($tmselect) or die "Couldn't prepare $tmselect query: ".DBI->errstr;
            $tmh->execute or die "Couldn't execute $tmselect query: ".DBI->errstr;
            for ( 1 .. $tmh->rows ) {
                $tmentry = $tmh->fetchrow_hashref;
                if ( $tmentry->{'TMarray'} ne '' ) {
                    $lastvalue = "$tmentry->{'TMarray'}";
                    print TESTS "CheckEnum(\"$tmentry->{'TMname'}\",$tmentry->{'TMname'},$tmentry->{'TMarray'},$tmentry->{'TMid'})\n";
                } else {
                    if ( $_ == 1 ) {
                        $lastvalue = 0;
                    } else {
			if ( $tmentry->{'TMvalue'} ne '' ) {
			    $lastvalue = $tmentry->{'TMvalue'};
			} else {
			    $lastvalue = $lastvalue + 1;
			}
                    }
                    print TESTS "CheckEnum(\"$tmentry->{'TMname'}\",$tmentry->{'TMname'},$lastvalue,$tmentry->{'TMid'})\n";
                }
            }
            $tmh->finish;
            next;
        }

        #case Typedef:
        if ( $tentry->{'Ttype'} eq 'Typedef' ) {

            # Need to check for Array, and adjust the size value accordingly

#            $tselect = "SELECT * FROM Type ";
#            $tselect .= "LEFT JOIN ArchType ON ATtid=Tid ";
#            $tselect .= "LEFT JOIN Architecture ON Aid=ATaid ";
#            $tselect .= "WHERE Tid=" . $tentry->{'ATbasetype'};
#           $tselect .= " AND (ATappearedin <> '' AND ATappearedin <= '$lsbversion' ";
#           $tselect .= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin > '$lsbversion') ) ";
# #             $tselect .= "OR Tindirect='Yes' )";
#           $ttth = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
#           $ttth->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
#            $ttentry = $ttth->fetchrow_hashref;
#           $ttth->finish;

            $baseselect = "SELECT Ttype, ATsize, COUNT(TMid) AS mem_cnt FROM Type ";
            $baseselect .= "LEFT JOIN ArchType ON ATbasetype=Tid ";
            $baseselect .= "LEFT JOIN TypeMember ON TMmemberof=Tid ";
            $baseselect .= "WHERE ATtid=$Tid ";
            $baseselect .= "AND ATappearedin <= '$lsbversion' AND ATappearedin > '' ";
            $baseselect .= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin > '$lsbversion') ";
            $baseselect .= "GROUP BY Tid ";
            print $baseselect, "\n" if $trace;
            $baseth = $dbh->prepare($baseselect) or die "Couldn't prepare $baseselect query: ".DBI->errstr;
            $baseth->execute or die "Couldn't execute $baseselect query: ".DBI->errstr;
            if( $baseth->rows ) {
                $baseentry = $baseth->fetchrow_hashref;
                if( ($baseentry->{'Ttype'} eq 'Struct' or $baseentry->{'Ttype'} eq 'Union' or $baseentry->{'Ttype'} eq 'Enum')
                        and $baseentry->{'mem_cnt'} == 0 ) {
                    $baseth->finish;
                    next;
                }

                if( $baseentry->{'Ttype'} eq 'Array' and !$baseentry->{'ATsize'} ) {
                    $baseth->finish;
                    next;
                }
            }
            $baseth->finish;

            $total_printed++;
            if( $idchanged ) {
                if( $tentry->{'Tname'} !~ /fptr/ ) {
                    print TESTS "#if $tentry->{'Asymbol'}\n";
                }
            } else {
                if( $tentry->{'Tname'} !~ /fptr/ ) {
                    print TESTS "#elif $tentry->{'Asymbol'}\n";
                }
            }
#           if ($ttentry->{'Tid'}) {
                $withdrawnin = $ATwithdrawnin ? "'$ATwithdrawnin'" : "NULL";
                $attribute = $ATattribute ? "'$ATattribute'" : "NULL";
                print TESTS "CheckTypeSize($Tname,$ATsize, $Tid, $Aid, $ATappearedin, $withdrawnin, $ATbasetype, $attribute)\n";
#           } else {
#               $tentry->{'ATaid'} = 0;
#           }

            next;
        }

        # case Const
        if ( $tentry->{'Ttype'} eq 'Const' ) {

            # need to get the basetype first
            $tselect = "SELECT * FROM Type ";
            $tselect .= "LEFT JOIN ArchType ON ATtid=Tid ";
            $tselect .= "LEFT JOIN Architecture ON Aid=ATaid ";
            $tselect .= "WHERE Tid=" . $tentry->{'ATbasetype'};
            $tselect .= " AND (ATappearedin <> '' AND ATappearedin <= '$lsbversion' ";
            $tselect .= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin > '$lsbversion') ) ";
            print $tselect, "\n" if $trace;
            $ttth = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
            $ttth->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
            $ttentry = $ttth->fetchrow_hashref;
            $ttth->finish;
            my $typeName;

            $withdrawnin = $ATwithdrawnin ? "'$ATwithdrawnin'" : "NULL";
            $attribute = $ATattribute ? "'$ATattribute'" : "NULL";
            if ( $ttentry->{'Ttype'} eq 'Typedef' || $ttentry->{'Ttype'} eq 'Pointer' ) {
                if ($ttentry->{'Ttype'} eq 'Typedef') {
                    $tselect = "SELECT * FROM Type ";
                    $tselect .= "LEFT JOIN ArchType ON ATtid=Tid ";
                    $tselect .= "LEFT JOIN Architecture ON Aid=ATaid ";
                    $tselect .= "WHERE (ATappearedin <> '' AND ATappearedin <= '$lsbversion' ";
                    $tselect .= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin > '$lsbversion') ) ";
                    $tselect .= "AND Tid=" . $ttentry->{'ATbasetype'};
                    $ttth = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
                    $ttth->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
                    $ttentry = $ttth->fetchrow_hashref;
                    $ttth->finish;
                    if ($ttentry->{'Tid'} or ($ttentry->{'ATbasetype'} == 0) ) {
                        print TESTS "CheckTypeSize($Tname,$ATsize, $Tid, $Aid, $ATappearedin, $withdrawnin, $ATbasetype, $attribute)\n";
                    }
                } else {
                    print TESTS "CheckTypeSize($Tname,$ATsize, $Tid, $Aid, $ATappearedin, $withdrawnin, $ATbasetype, $attribute)\n";
                }
            } else {
                $tentry->{'ATaid'} = 0;
            }

            next;
        }

        if ( $tentry->{'Ttype'} eq 'Class' ) {
            next;
        }

        # Default case
        $withdrawnin = $ATwithdrawnin ? "'$ATwithdrawnin'" : "NULL";
        print TESTS "CheckTypeSize($Tname,$ATsize, $Tid, $Aid, $ATappearedin, $withdrawnin, $ATbasetype, $attribute)\n"
        if $tentry->{'Ttype'} ne 'Array';
    }
    $tth->finish;

    if( not ( $Tname =~ /anon/ && $Ttype ne 'Enum') and (not ( $Tname =~ /fptr/ ) ) ) {
        if( $lastid and $total_printed ) {
            if( $lastaid != 1 ) {
                $selectGeneric = "SELECT count(*) as cnt FROM ArchType ";
                $selectGeneric.= "WHERE ATtid=$Tid AND ATaid=1 ";
                $selectGeneric.= "AND ATappearedin<>'' AND ATappearedin <= '$lsbversion' ";
                $selectGeneric.= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin > '$lsbversion') ";
                print $selectGeneric, "\n" if $trace;
                $gth = $dbh->prepare($selectGeneric) or die "Couldn't prepare $selectGeneric query: ".DBI->errstr;
                $gth->execute or die "Couldn't execute $selectGeneric query: ".DBI->errstr;
                $gentry = $gth->fetchrow_hashref;
                $gth->finish;
                if ($gentry->{'cnt'} > 0) {
                    print TESTS "#else\n";
                    print TESTS "Msg(\"Find size of $Tname ($Tid)\\n\");\n";
                    $withdrawnin = $ATwithdrawnin ? "'\"\"$ATwithdrawnin\"\"'" : "NULL";
                    $attribute = $ATattribute ? "'\"\"$ATattribute\"\"'" : "NULL";
                    print TESTS "Sql(\"REPLACE INTO ArchType VALUES (";
                    print TESTS "%d,%d,%d,'\"\"$ATappearedin\"\"',$withdrawnin,$ATbasetype, $attribute);\\n\",architecture,$Tid,0);\n";
                }
            }
            print TESTS "#endif\n\n";
        }
    }

    #
    # Test typedefs to functions
    #
    $lastid = 0;
    $select = "SELECT DISTINCT T1.*, Aid, Aname, Asymbol, ArchType.* FROM Type T1 ";
    $select.= "JOIN HeaderGroup ON T1.Theadgroup=HGid ";
    $select.= "JOIN ArchType ON ATtid=T1.Tid ";
    $select.= "JOIN Architecture ON Aid=ATaid ";
    $select.= "JOIN Type T2 ON T2.Tid=ATbasetype ";
    $select.= "WHERE HGheader=$Hid ";
    $select.= "AND T1.Ttype='Typedef' AND T2.Ttype='FuncPtr' ";
    $select.= "AND ATappearedin <= '$lsbversion' AND ATappearedin > '' ";
    $select.= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin >'$lsbversion')";
    $select.= "ORDER BY T1.Theadgroup, T1.Tid, Aid DESC ";
    $tth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $tth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    for ( 1 .. $tth->rows ) {
        $entry = $tth->fetchrow_hashref;

        $condition = "elif"; # "elif"
        if ( $entry->{'Tid'} != $lastid ) {
            if ( $lastid != 0 ) {
                print TESTS "#endif\n\n";
            }
            $condition = "if";
            $lastid = $entry->{'Tid'};
        }

        if( $entry->{'Aid'} == 1 ) {
            $printedMsgs = checkArchSpecific($entry->{'Tname'},$entry->{'Tid'},$condition,$entry->{'Ttype'});
            if( $printedMsgs > 0 ) {
                $lastid = $tentry->{'Tid'};
            }
            if( $printedMsgs != -1 ) {
                next;
            }
        }

        print TESTS "#".$condition." $entry->{'Asymbol'}\n";
        print TESTS "/* $entry->{'Aname'} */\n";

        print TESTS "typedef ";
        $RetType = $dbh->selectrow_array("SELECT ATbasetype FROM ArchType WHERE ATtid=".$entry->{'ATbasetype'}." LIMIT 1");
        if( !$RetType ) {
            print STDERR "Couldn't detect return type for FuncPtr with Tid=".$entry->{'ATbasetype'}."\n";
            next;
        }
        $selectReturn = "SELECT * FROM Type ";
        $selectReturn.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $selectReturn.= "WHERE Tid=$RetType ";
        $selectReturn.= "AND (ATaid=1 OR ATaid=".$entry->{'Aid'}.") ";
        $selectReturn.= "ORDER BY ATaid DESC"; # we'll take only one record - arch-specific (if any) or generic
        print $selectReturn, "\n" if $trace;
        $rth = $dbh->prepare($selectReturn) or die "Couldn't prepare $selectReturn query: ".DBI->errstr;
        $rth->execute or die "Couldn't execute $selectReturn query: ".DBI->errstr;
        $rentry = $rth->fetchrow_hashref;

        displaytyperef( $rentry, 1, $rentry->{'ATaid'} );
        print TESTS " (*$entry->{'Tname'}_db)";
        $rth->finish;

        $selectParams = "SELECT * FROM TypeMember ";
        $selectParams.= "JOIN Type ON Tid=TMtypeid ";
        $selectParams.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $selectParams.= "WHERE TMmemberof=".$entry->{'ATbasetype'};
        $selectParams.= " AND (TMaid=1 OR TMaid=".$entry->{'Aid'}.")";
        $selectParams.= " AND TMappearedin > '' AND TMappearedin <= '$lsbversion' ";
        $selectParams.= " AND (TMwithdrawnin IS NULL OR TMwithdrawnin > '$lsbversion') ";
        $selectParams.= "GROUP BY TMposition ORDER BY TMposition ";
        print $selectParams, "\n" if $trace;
        $sth2 = $dbh->prepare($selectParams) or die "Couldn't prepare $selectParams query: ".DBI->errstr;
        $sth2->execute or die "Couldn't execute $selectParams query: ".DBI->errstr;
        print TESTS "(";
        if ( $sth2->rows ) {
            for ( 1 .. $sth2->rows ) {
                $entry2 = $sth2->fetchrow_hashref;

                displaytyperef( $entry2, 1, $entry->{'Aid'} );
                if ( $entry2->{'Ttype'} eq "Array" ) {
                    print TESTS "[";
                    if ( $entry2->{'ATsize'} != 0 ) {
                        print TESTS "$entry2->{'ATsize'}";
                    }
                    print TESTS "]";
                }
                if ( $_ != $sth2->rows ) { print TESTS ", "; }
            }
        } else {
            print TESTS "void";
        }
        $sth2->finish;
        print TESTS ");\n";
        print TESTS "CheckFunctionTypedef($entry->{'Tname'},$entry->{'Tname'}_db);\n";
    }
    $tth->finish;
    if( $lastid ) {
        print TESTS "#endif\n\n";
    }

    #
    # Interface testing
    #
    my $math = 0;
    my $special;

    if ( $Hname =~ /math\.h/ ) {
        #print "Found math header\n";
        $mathhdr = 1;
    }

        for ( 1 .. $ith->rows ) {
            $special = 0;
            $entry = $ith->fetchrow_hashref;
            if ( $mathhdr ) { $special = grep /^$entry->{'Iname'}$/, @mathsyms; }
            if ( $entry->{'Itype'} eq "Function" ) {
                if ( $entry->{'Ttype'} eq 'FuncPtr' ) {
                    print STDERR "Skipping a global function pointer!!\n";
                    next;
                }

                if ( $entry->{'Aid'} && $entry->{'Aname'} ne "All" ) {
                    $selectCheck ="SELECT AIarch FROM ArchInt ";
                    $selectCheck.="WHERE AIarch=1 AND AIint=$entry->{'Iid'} ";
            $selectCheck.="AND AIappearedin > '' AND AIappearedin <= '$lsbversion' ";
            $selectCheck.="AND (AIwithdrawnin IS NULL OR AIwithdrawnin > '$lsbversion') ";
            $selectCheck.= "LIMIT 1";
                    print $selectCheck, "\n" if $trace;
                    $sthCheck = $dbh->prepare($selectCheck) or die "Couldn't prepare $selectCheck query: ".DBI->errstr;
                    $sthCheck->execute or die "Couldn't execute $selectCheck query: ".DBI->errstr;
                    if( $sthCheck->rows ) {
                        $sthCheck->finish;
                        next;
                    }
                    $sthCheck->finish;
                }

                if ( $entry->{'Aid'} && $entry->{'Aname'} ne "All" ) {
                    print TESTS "#if $entry->{'Asymbol'}\n";
                    print TESTS "/* $entry->{'Aname'} */\n";
                }
                elsif ( $special) {
                    print TESTS $mathstring;
                }

                # Class interfaces are not checked at the moment...
                if( $entry->{'Iclass'} == 0 ) {
                    print TESTS "extern ";
                    displaytyperef( $entry, 1, $entry->{'Aid'} );
                    print TESTS " $entry->{'Iname'}_db(";

                    $select = "SELECT Tid,Tname,Ttype,ATbasetype,Parsize FROM Parameter,Type ";
                    $select .= "LEFT JOIN ArchType ON ATtid=Tid ";
                    $select .= "WHERE Pint=" . $entry->{'Iid'} . " AND Ptype=Tid ";
                    $select .= "GROUP BY Ppos ORDER BY Ppos";
                    print $select, "\n" if $trace;
                    $sth2 = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
                    $sth2->execute or die "Couldn't execute $select query: ".DBI->errstr;
                    if ( $sth2->rows ) {
                        for ( 1 .. $sth2->rows ) {
                            $entry2 = $sth2->fetchrow_hashref;

                            displaytyperef( $entry2, 1, $entry->{'Aid'} );
                            if ( $entry2->{'Ttype'} eq "Array" ) {
                                print TESTS "[";
                                if ( $entry2->{'Parsize'} != 0 ) {
                                    print TESTS "$entry2->{'Parsize'}";
                                }
                                print TESTS "]";
                            }
                            if ( $_ != $sth2->rows ) { print TESTS ", "; }
                        }
                    } else {
                        print TESTS "void";
                    }
                    $sth2->finish;
                    print TESTS ");\n";
                    print TESTS "CheckInterfacedef($entry->{'Iname'},$entry->{'Iname'}_db);\n";
                }

                if ( $entry->{'Aid'} && $entry->{'Aname'} ne "All" ) {
                    print TESTS "#endif\n";
                }
                elsif ( $special) {
                    print TESTS "#endif     /* hack */\n";
                }
            }
            elsif ( $entry->{'Itype'} eq "Data" ) {
        if( $entry->{'Ttype'} eq 'Array' or $entry->{'Ttype'} eq 'Const' or $entry->{'Ttype'} eq 'Pointer' ) {
            next;
        }

                if ( $entry->{'Aid'} && $entry->{'Aname'} ne "All" ) {
                    print TESTS "#if $entry->{'Asymbol'}\n";
                    print TESTS "/* $entry->{'Aname'} */\n";
                }

        # We can have different types of variables on different architectures
        # (currently this can happen for arrays only)
                if ( $entry->{'Aid'} && $entry->{'Aname'} eq "All" ) {
                    $selectCheck ="SELECT AIarch FROM ArchInt ";
                    $selectCheck.="WHERE AIarch > 1 AND AIint=$entry->{'Iid'} ";
                    $selectCheck.="AND AIappearedin > '' AND AIappearedin <= '$lsbversion' ";
                    $selectCheck.="AND (AIwithdrawnin IS NULL OR AIwithdrawnin > '$lsbversion') ";
                    $selectCheck.= "LIMIT 1";
                    print $selectCheck, "\n" if $trace;
                    $sthCheck = $dbh->prepare($selectCheck) or die "Couldn't prepare $selectCheck query: ".DBI->errstr;
                    $sthCheck->execute or die "Couldn't execute $selectCheck query: ".DBI->errstr;
                    if( $sthCheck->rows ) {
                        $sthCheck->finish;
                        next;
                    }
                    $sthCheck->finish;
                }

                displaytyperef( $entry, 0, $entry->{'Aid'} );
                print TESTS " $entry->{'Iname'}_db";
                if ( $entry->{'Ttype'} eq "Array" ) {
                    print TESTS "[";
                    if ( $entry->{'ATsize'} != 0 ) {
                        print TESTS $entry->{'ATsize'};
                    }
                    print TESTS "]";
                }
                print TESTS " ;\n";
                print TESTS "CheckGlobalVar($entry->{'Iname'}_db, $entry->{'Iname'});\n";

                if ( $entry->{'Aid'} && $entry->{'Aname'} ne "All" ) {
                    print TESTS "#endif\n";
                }
            }
        }
        $ith->finish;

    print TESTS "#ifdef TET_TEST\n";
    print TESTS "if (pcnt == cnt )\n";
    print TESTS "\ttet_result(TET_PASS);\n";
    print TESTS "else\n";
    print TESTS "\ttet_result(TET_FAIL);\n";
    print TESTS "return;\n";
    print TESTS "#else\n";
    print TESTS "Msg(\"%d tests passed out of %d tests in $Hname\\n\\n\",pcnt,cnt);\n";
    print TESTS "return cnt;\n";
    print TESTS "#endif\n\n";
    print TESTS "}\n";

    close(TESTS);
}

$dbh = DBI->connect('DBI:mysql:database='.$LSBDB.';host='.$LSBDBHOST, $LSBUSER, $LSBDBPASSWD)
    or die "Couldn't connect to database: ".DBI->errstr;

if ( $ARGV[0] ne "" ) {
    $select = "SELECT DISTINCT * FROM Header ";
    $select.= "WHERE Happearedin <= '$lsbversion' AND Happearedin > '' ";
    $select.= "AND (Hwithdrawnin IS NULL OR Hwithdrawnin > '$lsbversion' ) ",
    $select.= "AND Hname='" . $ARGV[0] . "'";
    print $select, "\n" if $trace;
    $hth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $hth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    $entry = $hth->fetchrow_hashref;
    $hth->finish;
    writetest( $entry->{'Hid'}, $entry->{'Hname'} );
    $dbh->disconnect;
    exit;
}

open( HARNESS, ">hdrchk.c" ) || die "Can't open hdrchk.c for writing";
print HARNESS "#include <stdio.h>\n";
print HARNESS "#include <stdarg.h>\n\n";
open( MAKEFILE, ">makefile" ) || die "Can't open makefile for writing";

#print MAKEFILE "CFLAGS = -g -I../../headers\n";
print MAKEFILE "OBJS = hdrchk.o ";

$select = "SELECT * FROM Architecture ";
$select .= "WHERE Aname!='All'";
print $select, "\n" if $trace;

$ath = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$ath->execute or die "Couldn't execute $select query: ".DBI->errstr;
for ( 1 .. $ath->rows ) {
    $entry = $ath->fetchrow_hashref;
    print HARNESS "#if ",             $entry->{'Asymbol'}, "\n";
    print HARNESS "int architecture=", $entry->{'Aid'},  ";\n";
    print HARNESS "#define __found_arch__\n";
    print HARNESS "#endif\n";
}
$ath->finish;

print HARNESS "#ifndef __found_arch__\n";
print HARNESS "#error \"Unable to identify architecture\"\n";
print HARNESS "#endif\n\n";

print HARNESS "#ifdef TET_TEST\n\n";
print HARNESS "#include \"hdrchk_tet.h\"\n\n";
print HARNESS "#endif\n\n";

print HARNESS "Msg( char *f, ...)\n";
print HARNESS "{\n";
print HARNESS "va_list args;\n";
print HARNESS "va_start(args,f);\n";
print HARNESS "fprintf(stdout, \"-- \");\n";
print HARNESS "vfprintf(stdout, f, args);\n";
print HARNESS "va_end(args);\n";
print HARNESS "}\n\n";
print HARNESS "Sql( char *f, ...)\n";
print HARNESS "{\n";
print HARNESS "va_list args;\n";
print HARNESS "va_start(args,f);\n";
print HARNESS "vfprintf(stdout, f, args);\n";
print HARNESS "va_end(args);\n";
print HARNESS "}\n\n";
print HARNESS "Log( char *f, ...)\n";
print HARNESS "{\n";
print HARNESS "/* Quietly drop extraneous messages when running in non TET mode */\n";
print HARNESS "}\n\n";
print HARNESS "int tcnt=0;\n\n";
print HARNESS "#ifndef TET_TEST\n\n";
print HARNESS "main()\n{\n";

open( TET_HDR, ">hdrchk_tet.h" ) || die "Can't open hdrchk_tet.h for writing";
print TET_HDR "#include <tet_api.h>\n\n";
print TET_HDR "#include \"testdefs.h\"\n\n";

print TET_HDR "static void startup(), cleanup();\n\n";
print TET_HDR "void (*tet_startup)() = NULL;\n";
print TET_HDR "void (*tet_cleanup)() = NULL;\n\n";
print TET_HDR "struct tet_testlist tet_testlist[] = {\n";

open( SUBDEFS, ">testdefs.h" ) || die "Can't open testdefs.h for writing";

$select = "SELECT * FROM Header ";
$select.= "LEFT JOIN Library ON Hlib=Lid ";
$select.= "WHERE Happearedin <= '$lsbversion' AND Happearedin > '' ";
$select.= "AND (Hwithdrawnin IS NULL OR Hwithdrawnin > '$lsbversion' ) ",
$select.= "AND Lname NOT IN ('libQtCore','libQtGui','libQtNetwork','libQtXml','libQtOpenGL','libQtSql','libQtSvg') ";
$select.= "ORDER BY Hname ";

#
# Dump out each header
#
$hth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$hth->execute or die "Couldn't execute $select query: ".DBI->errstr;
for ( 1 .. $hth->rows ) {
    $entry = $hth->fetchrow_hashref;
    $uniqFptrNum = 0;
    writetest( $entry->{'Hid'}, $entry->{'Hname'} );
}
$hth->finish;

#
# Dump out the fundamental types (Intrinsic types)
#
open( TESTS, ">intrinsic.c" ) || die "Can't open intrinsic.c for writing";

# Get Types
$select = "SELECT DISTINCT * FROM Type ";
$select .= "LEFT JOIN ArchType ON ATtid=Tid ";
$select .= "LEFT JOIN Architecture ON Aid=ATaid ";
$select .= "WHERE Ttype='Intrinsic' ";
$select .= "AND Tname NOT IN ('...','bool') ";
$select .= "ORDER BY Tid,ATaid";
$tth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$tth->execute or die "Couldn't execute $select query: ".DBI->errstr;
if ( $tth->rows == 0 ) {
    print TESTS "/*\n * No values in $Hname\n */\n";
    close(TESTS);
    $tth->finish;
    $dbh->disconnect;
    return;
}

print MAKEFILE "\\\n\tintrinsic.o ";
print HARNESS "tcnt+=intrinsic();\n";

print TESTS "/*\n * Test of intrinsic types\n */\n";
print TESTS "#include \"hdrchk.h\"\n";
print TESTS "#include \<stdio.h\>\n";
print TESTS "#include \<sys/types.h\>\n";
print TESTS "#include \<complex.h\>\n";
print TESTS "\n\n\n";
print TESTS "#ifdef TET_TEST\n";
print TESTS "void intrinsic()\n{\n";
print TESTS "#else\n";
print TESTS "int intrinsic()\n{\n";
print TESTS "#endif\n";
print TESTS "int cnt=0;\n";
print TESTS "int pcnt=0;\n";
print TESTS "#ifdef TET_TEST\n";

#print TESTS "int pcnt=0;\n";
print TESTS "#endif\n\n";
print TESTS "Msg(\"Checking Intrinsic types\\n\");\n";

$lastid = 0;
for ( 1 .. $tth->rows ) {
    $tentry = $tth->fetchrow_hashref;

    # Do this before we reset the value, so we can re-use the values
    # from the last time through the loop if we need them
    #

    if( $tentry->{'Aid'}==1 && $tentry->{'ATsize'}==0 ) {
        $selectArchSpecific = "SELECT * FROM ArchType ";
        $selectArchSpecific.= "WHERE ATaid<>1 ";
        $selectArchSpecific.= "AND ATtid=".$tentry->{'Tid'}; # do not check status here - the types are intrinsic
        $ath = $dbh->prepare($selectArchSpecific)
            or die "Couldn't prepare $selectArchSpecific query: ".DBI->errstr;
        $ath->execute or die "Couldn't execute $selectArchSpecific query: ".DBI->errstr;
        if ( $ath->rows != 0 ) {
            # arch specific records found - skip generic
            next;
        }
        $ath->finish;
    }

    if ( $tentry->{'Tid'} != $lastid ) {
        if ( $lastid != 0 ) {

            # We have output at least one type, and now we need to
            # put a catch-all else clause
            #
            $selectGeneric = "SELECT count(*) as cnt FROM ArchType ";
            $selectGeneric.= "WHERE ATtid=$Tid AND ATaid=1 ";
            $gth = $dbh->prepare($selectGeneric)
                or die "Couldn't prepare $selectGeneric query: ".DBI->errstr;
            $gth->execute or die "Couldn't execute $selectGeneric query: ".DBI->errstr;
            $gentry = $gth->fetchrow_hashref;
            if ($gentry->{'cnt'} > 0) {
                print TESTS "#else\n";
                print TESTS "Sql(\"REPLACE INTO ArchType VALUES (";
                print TESTS "%d,%d,%d,'\"\"\"\"',\"\"NULL\"\",0,NULL);\\n\",architecture,$Tid,0);\n";
                print TESTS "#endif\n\n";
            }
            $gth->finish;
        }
        print TESTS "#if $tentry->{'Asymbol'}\n";
        $lastid = $tentry->{'Tid'};
    } else {
        print TESTS "#elif $tentry->{'Asymbol'}\n";
    }
    $Tid    = $tentry->{'Tid'};
    $ATsize = $tentry->{'ATsize'};
    $Aid    = $tentry->{'Aid'};
    $Tname  = $tentry->{'Tname'};
    $ATbasetype  = $tentry->{'ATbasetype'};
    $ATattribute = $tentry->{'ATattribute'};

    $attribute = $ATattribute ? "'$ATattribute'" : "NULL";

    print TESTS "CheckTypeSize($Tname,$ATsize,$Tid,$Aid, \"\", \"NULL\",0,\"NULL\")\n";
}
$tth->finish;
print TESTS "#else\n";
print TESTS "Sql(\"REPLACE INTO ArchType VALUES (";
print TESTS "%d,%d,%d,'\"\"\"\"',\"\"NULL\"\",0,\"\"NULL\"\");\\n\",architecture,$Tid,0);\n";
print TESTS "#endif\n\n";

print TESTS "#ifdef TET_TEST\n";
print TESTS "if (pcnt == cnt)\n";
print TESTS "\ttet_result(TET_PASS);\n";
print TESTS "else\n";
print TESTS "\ttet_result(TET_FAIL);\n";
print TESTS "return;\n";
print TESTS "#else\n";
print TESTS "Msg(\"%d tests passed out of %d tests intrinsic types\\n\\n\",pcnt,cnt);\n";
print TESTS "return cnt;\n";
print TESTS "#endif\n\n";
print TESTS "}\n";
close(TEST);

#
# Dump out the C++ types (Class types)
#
open( TESTS, "|c++filt >cxx.C" ) || die "Can't open cxx.C for writing";

# Get Types
$select = "SELECT DISTINCT * FROM Type ";
$select .= "LEFT JOIN ArchType ON ATtid=Tid ";
$select .= "LEFT JOIN Architecture ON Aid=ATaid ";
$select .= "WHERE Ttype='Class' AND Theadgroup<669 ";
$select .= "AND ATappearedin <> '' AND ATappearedin <='$lsbversion' ";
$select .= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin >'$lsbversion') ";
$select .= "ORDER BY Tname,ATaid";
$tth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$tth->execute or die "Couldn't execute $select query: ".DBI->errstr;
if ( $tth->rows == 0 ) {
    print TESTS "/*\n * No values in $Hname\n */\n";
    close(TESTS);
    $tth->finish;
    $dbh->disconnect;
    return;
}

print MAKEFILE "\\\n\tcxx.o ";
print HARNESS "tcnt+=cxx();\n";

print TESTS "/*\n * Test of c++ types\n */\n";
print TESTS "#include <fstream>\n";
print TESTS "#include <ios>\n";
print TESTS "#include <istream>\n";
print TESTS "#include <iterator>\n";
print TESTS "#include <limits>\n";
print TESTS "#include <locale>\n";
print TESTS "#include <numeric>\n";
print TESTS "#include <stdexcept>\n";
print TESTS "#include <string>\n";
print TESTS "#include <sstream>\n";
print TESTS "#include <valarray>\n";
print TESTS "#include <vector>\n";
if( $lsbversion < '3.0' ) {
    # Old LSB versions had stuff from strstream header
    print TESTS "#include <backward/strstream>\n";
}
print TESTS "#include <ext/stdio_filebuf.h>\n";
print TESTS "#include <cxxabi.h>\n";
print TESTS "#include \"hdrchk.h\"\n";
print TESTS "\n\n\n";
print TESTS "extern \"C\" {\n";
print TESTS "#ifdef TET_TEST\n";
print TESTS "void cxx();\n";
print TESTS "#else\n";
print TESTS "int cxx();\n";
print TESTS "#endif\n";
print TESTS "}\n\n";
print TESTS "#ifdef TET_TEST\n";
print TESTS "void cxx()\n{\n";
print TESTS "#else\n";
print TESTS "int cxx()\n{\n";
print TESTS "#endif\n";
print TESTS "int cnt=0;\n";
print TESTS "int pcnt=0;\n";
print TESTS "#ifdef TET_TEST\n";

#print TESTS "int pcnt=0;\n";
print TESTS "#endif\n\n";
print TESTS "Msg(\"Checking C++ types\\n\");\n";

$lastid = 0;
for ( 1 .. $tth->rows ) {
    $tentry = $tth->fetchrow_hashref;

    $condition = "elif"; # "elif"
    if ( $tentry->{'Tid'} != $lastid ) {
        if ( $lastid != 0 ) {
            $condition = "endif";
        }
        $condition = "if";
    }

    if( $tentry->{'Aid'} == 1 ) {
        $printedMsgs = checkArchSpecific($tentry->{'Tname'},$tentry->{'Tid'},$condition,$tentry->{'Ttype'});
        if( $printedMsgs > 0 ) {
            $lastid = $tentry->{'Tid'};
        }
        if( $printedMsgs != -1 ) {
            next;
        }
    }

    # Do this before we reset the value, so we can re-use the values
    # from the last time through the loop if we need them
    if ( $tentry->{'Tid'} != $lastid ) {
        if ( $lastid != 0 ) {

            # We have output at least one type, and now we need to
            # put a catch-all else clause

            print TESTS "#else\n";
            $withdrawnin = $ATwithdrawnin ? "'\"\"$ATwithdrawnin\"\"'" : "NULL";
            $attribute = $ATattribute ? "'\"\"$ATattribute\"\"'" : "NULL";
            print TESTS "Sql(\"REPLACE INTO ArchType VALUES (";
            print TESTS "%d,%d,%d,'\"\"$ATappearedin\"\"',$withdrawnin,$ATbasetype,$attribute);\\n\",architecture,$Tid,0);\n";
            print TESTS "#endif\n\n";
        }

        # Hope the check for zero ATsize is temporary; but we have a lot of 'classes'
        # without any additional information (Qt classes) and their presence will break
        # devchk compilation
        if ( !$tentry->{'Asymbol'} or $tentry->{'ATsize'} == 0 ) {
            $tentry->{'Asymbol'} = '0';
        }
        print TESTS "#if $tentry->{'Asymbol'}\n";
        $lastid = $tentry->{'Tid'};
    } else {
        print TESTS "#elif $tentry->{'Asymbol'}\n";
    }
    $Tid    = $tentry->{'Tid'};
    $ATsize = $tentry->{'ATsize'};
    $Aid    = $tentry->{'Aid'};
    $Tname  = $tentry->{'Tname'};
    $ATappearedin  = $tentry->{'ATappearedin'};
    $ATwithdrawnin = $tentry->{'ATwithdrawnin'};
    $ATbasetype = $tentry->{'ATbasetype'};
    $ATattribute   = $tentry->{'ATattribute'};

    # Unmangled types have commas, which confuse the preprocessor
    if( $Tname =~ "^_Z" ) {
       print TESTS "#define TYPE $Tname\n";
    }
    else {
       print TESTS "#define TYPE _Z$Tname\n";
    }
    $withdrawnin = $ATwithdrawnin ? "'$ATwithdrawnin'" : "NULL";
    $attribute = $ATattribute ? "'$ATattribute'" : "NULL";
    print TESTS "CheckTypeSize(TYPE,$ATsize,$Tid,$Aid, $ATappearedin, $withdrawnin, $ATbasetype, $attribute)\n";
    print TESTS "#undef TYPE\n";
}
$tth->finish;
$withdrawnin = $ATwithdrawnin ? "'\"\"$ATwithdrawnin\"\"'" : "NULL";
$attribute = $ATattribute ? "'\"\"$ATattribute\"\"'" : "NULL";
print TESTS "#else\n";
print TESTS "Sql(\"REPLACE INTO ArchType VALUES (";
print TESTS "%d,%d,%d,'\"\"$ATappearedin\"\"',$withdrawnin,$ATbasetype,$attribute);\\n\",architecture,$Tid,0);\n";
print TESTS "#endif\n\n";

print TESTS "#ifdef TET_TEST\n";
print TESTS "if (pcnt == cnt )\n";
print TESTS "\ttet_result(TET_PASS);\n";
print TESTS "else\n";
print TESTS "\ttet_result(TET_FAIL);\n";
print TESTS "return;\n";
print TESTS "#else\n";
print TESTS "Msg(\"%d tests passed out of %d tests in C++ types\\n\\n\",pcnt,cnt);\n";
print TESTS "return cnt;\n";
print TESTS "#endif\n\n";
print TESTS "}\n";
close(TESTS);

#
# Finish up and close the files
#
print MAKEFILE "\n\n";
print MAKEFILE "ifdef TET_ROOT\n";
print MAKEFILE "LIBDIR = \$\(TET_ROOT)/lib/tet3\n";
print MAKEFILE "INCDIR = \$\(TET_ROOT)/inc/tet3\n";
print MAKEFILE "EXTRALIBS = \$\(LIBDIR)/tcm.o \$\(LIBDIR)/libapi.a\n";
print MAKEFILE "else\n";
print MAKEFILE "EXTRALIBS =\n";
print MAKEFILE "endif\n\n";

if( $lsbversion ge "4.0" ) {
    print MAKEFILE "# There is no need in this flag since LSB 4.0\n";
    print MAKEFILE "LDBL_FLAG = \n\n";
}
else {
    print MAKEFILE "# for LSB 3.2, must force the old 64-bit long double ABI for some arches\n";
    print MAKEFILE "LDBL_FLAG:=\$(shell case `uname -m` in (ppc|ppc64|s390|s390x) echo \"-mlong-double-64\";; (*) echo ;; esac)\n\n";
}

print MAKEFILE "# File with CFLAGS and CXXFLAGS\n";
print MAKEFILE "include cflags.mk\n\n";

print MAKEFILE "all: hdrchk\n\n";
print MAKEFILE "hdrchk: \$\(OBJS)\n";
print MAKEFILE "\t\$(CXX) -o hdrchk \$(OBJS) \$(EXTRALIBS) -L/usr/X11R6/lib64 -L/usr/X11R6/lib -L/usr/lib/qt3/lib64 -L/usr/lib/qt3/lib -L/usr/lib64/qt-3.3/lib -L/usr/lib/qt-3.3/lib -L/opt/gnome/lib64 -L/opt/gnome/lib -lXt -lX11 -lncurses -lqt-mt -lrt -lxml2 -lglib-2.0 -lgdk-x11-2.0 -lgtk-x11-2.0\n";
print MAKEFILE "\n";
print MAKEFILE "hdrchk.o: hdrchk.c\n";
print MAKEFILE "\t\$(CC) \$\(CFLAGS) -g -c hdrchk.c\n";
print MAKEFILE "\n\n";
print MAKEFILE "hdrchk.c:\n";
print MAKEFILE "\t./mktests -v `cat LSB_VERSION`\n";
print MAKEFILE "\n\n";
print MAKEFILE "gensrc: hdrchk.c\n";
print MAKEFILE "\n\n";
print MAKEFILE "install:\n";
print MAKEFILE "\n\n";
print MAKEFILE "clean:\n\trm -f \$\(OBJS) hdrchk\n\n";
print MAKEFILE "clobber:\tclean\n";
print MAKEFILE "\trm -f *.c hdrchk_tet.h testdefs.h\n";
print MAKEFILE "\n\n";
print MAKEFILE "distclean:\tclobber\n";
close(MAKEFILE);

print HARNESS "Msg(\"Total Tests: %d\\n\", tcnt );\n";
print HARNESS "}\n";
print HARNESS "#endif\n";
close(HARNESS);

print TET_HDR "\t{ NULL, 0 }\n";
print TET_HDR "};\n";
close(TET_HDR);
close(SUBDEFS);

$dbh->disconnect;

